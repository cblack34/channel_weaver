# YAML Configuration Implementation Plan

## Overview

This document outlines the complete implementation plan for converting Channel Weaver's configuration system from Python dictionaries (in `src/config/defaults.py`) to a YAML-based configuration file system. The implementation enables:

1. **External YAML config files** - User-editable configuration without modifying source code
2. **CLI config file option** - Pass a custom config file path via `--config` / `-c`
3. **Default config location** - Automatic discovery of config in current working directory
4. **Config generation command** - New `init-config` subcommand to create example config files
5. **Config validation command** - New `validate-config` subcommand to check config files
6. **Schema versioning** - Version field for future schema migrations

### Design Principles

This implementation follows **SOLID principles**, particularly:

- **Interface Segregation**: Config sources implement a protocol interface
- **Dependency Inversion**: High-level modules depend on abstractions, not concrete implementations
- **Open/Closed**: Easy to add new config sources (JSON, TOML, etc.) without modifying existing code

---

## Dependencies

### New Dependency: PyYAML

Add PyYAML to the project dependencies in `pyproject.toml`:

```toml
dependencies = [
    # ... existing dependencies ...
    "pyyaml>=6.0.1",
]
```

**Installation:**
```bash
uv add pyyaml
```

**Rationale:**
- PyYAML is the most widely-used YAML library for Python
- High trust score (7.4) with 37+ code snippets in documentation
- Supports safe loading via `yaml.safe_load()` to prevent arbitrary code execution
- Well-maintained with LibYAML C bindings for performance (optional)

**Key PyYAML API (validated via Context7):**
- `yaml.safe_load(stream)` - Parse YAML safely from string or file
- `yaml.safe_dump(data, file, ...)` - Serialize Python objects to YAML
- `yaml.YAMLError` - Base exception for YAML parsing errors

---

## YAML Configuration Schema

### File Structure

```yaml
# channel_weaver.yaml - Example Configuration File
# Generated by: channel-weaver init-config

# Schema version for future compatibility
schema_version: 1

# Channels Configuration
# Each channel defines how input audio channels are processed
# 
# Fields:
#   ch: (required) Input channel number (1-based)
#   name: (required) Display name for the channel
#   action: (optional) PROCESS | SKIP | BUS (default: PROCESS)
#   output_ch: (optional) Output channel number for filename (default: same as ch)
channels:
  - ch: 1
    name: Kick
    
  - ch: 2
    name: Snare Top
    action: SKIP
    
  - ch: 7
    name: Overhead L
    action: BUS
    
  - ch: 8
    name: Overhead R
    action: BUS
    
  - ch: 21
    name: Snare Top
    output_ch: 2

# Buses Configuration
# Buses combine multiple channels into stereo (or other) output files
#
# Fields:
#   file_name: (required) Output filename (without extension)
#   type: (optional) STEREO (default: STEREO, future: MONO, LCR, etc.)
#   slots: (required) Mapping of slot positions to input channel numbers
buses:
  - file_name: 07_Overheads
    type: STEREO
    slots:
      LEFT: 7
      RIGHT: 8
      
  - file_name: 19_Loop
    type: STEREO
    slots:
      LEFT: 19
      RIGHT: 20
```

### Schema Validation

The existing Pydantic models (`ChannelConfig`, `BusConfig`) already handle validation. The YAML loader will:
1. Parse YAML to Python dicts
2. Validate `schema_version` for compatibility
3. Pass dicts to existing Pydantic models
4. Leverage existing validation (field constraints, enum conversions, cross-field validation)

### Schema Versioning

The `schema_version` field enables future migrations:

| Version | Description |
|---------|-------------|
| 1 | Initial schema with channels and buses |

---

## Implementation Tasks

### Task 1: Create Config Source Protocol

**File:** `src/config/protocols.py`

```python
"""Protocol definitions for configuration sources."""

from pathlib import Path
from typing import Any, Protocol, runtime_checkable


@runtime_checkable
class ConfigSource(Protocol):
    """Protocol for configuration data sources.
    
    This protocol defines the interface that all configuration sources
    must implement. Following the Dependency Inversion Principle, the
    ConfigLoader depends on this abstraction rather than concrete
    implementations.
    
    Implementations include:
    - YAMLConfigSource: Load from YAML files
    - DefaultConfigSource: Built-in Python defaults
    - (Future) JSONConfigSource, TOMLConfigSource, etc.
    """
    
    def load(self) -> tuple[list[dict[str, Any]], list[dict[str, Any]], int]:
        """Load configuration data from the source.
        
        Returns:
            Tuple of (channels_data, buses_data, schema_version) where:
            - channels_data: List of channel configuration dictionaries
            - buses_data: List of bus configuration dictionaries
            - schema_version: Schema version number (1 for built-in defaults)
        
        Raises:
            ConfigError: If configuration cannot be loaded or is invalid
        """
        ...
    
    @property
    def source_description(self) -> str:
        """Human-readable description of the config source.
        
        Returns:
            Description string for logging/error messages
            e.g., "YAML file: /path/to/config.yaml" or "built-in defaults"
        """
        ...


# Current supported schema version
CURRENT_SCHEMA_VERSION = 1
```

**Key Implementation Notes:**
- Uses `@runtime_checkable` for isinstance() checks
- Returns schema_version as part of load() for validation
- `source_description` property for user-friendly messages
- Follows Interface Segregation - minimal required interface

---

### Task 2: Create YAML Config Source

**File:** `src/config/yaml_source.py`

```python
"""YAML configuration source for Channel Weaver."""

from pathlib import Path
from typing import Any

import yaml

from src.config.protocols import CURRENT_SCHEMA_VERSION
from src.exceptions import ConfigError


class YAMLConfigError(ConfigError):
    """Exception raised for YAML configuration file errors."""
    pass


class YAMLConfigSource:
    """Load configuration from YAML files.
    
    Implements the ConfigSource protocol for YAML file loading.
    
    Attributes:
        config_path: Path to the YAML configuration file
    """
    
    def __init__(self, config_path: Path) -> None:
        """Initialize the YAML config source.
        
        Args:
            config_path: Path to the YAML configuration file
            
        Raises:
            YAMLConfigError: If the file does not exist
        """
        self._config_path = config_path
        if not config_path.exists():
            raise YAMLConfigError(f"Configuration file not found: {config_path}")
        if not config_path.is_file():
            raise YAMLConfigError(f"Configuration path is not a file: {config_path}")
    
    @property
    def source_description(self) -> str:
        """Human-readable description of the config source."""
        return f"YAML file: {self._config_path}"
    
    def load(self) -> tuple[list[dict[str, Any]], list[dict[str, Any]], int]:
        """Load and parse the YAML configuration file.
        
        Returns:
            Tuple of (channels_data, buses_data, schema_version)
            
        Raises:
            YAMLConfigError: If YAML parsing fails or structure is invalid
        """
        try:
            with open(self._config_path, 'r', encoding='utf-8') as f:
                data = yaml.safe_load(f)
        except yaml.YAMLError as e:
            error_msg = f"Failed to parse YAML configuration: {e}"
            if hasattr(e, 'problem_mark') and e.problem_mark is not None:
                mark = e.problem_mark
                error_msg += f" (line {mark.line + 1}, column {mark.column + 1})"
            raise YAMLConfigError(error_msg) from e
        
        if data is None:
            raise YAMLConfigError("Configuration file is empty")
        
        if not isinstance(data, dict):
            raise YAMLConfigError(
                f"Configuration must be a YAML mapping, got {type(data).__name__}"
            )
        
        return self._extract_config(data)
    
    def _extract_config(
        self, data: dict[str, Any]
    ) -> tuple[list[dict[str, Any]], list[dict[str, Any]], int]:
        """Extract channels, buses, and schema version from parsed YAML.
        
        Args:
            data: Parsed YAML data as a dictionary
            
        Returns:
            Tuple of (channels_data, buses_data, schema_version)
            
        Raises:
            YAMLConfigError: If required sections are missing or invalid
        """
        # Extract and validate schema version
        schema_version = data.get('schema_version', 1)
        if not isinstance(schema_version, int):
            raise YAMLConfigError(
                f"'schema_version' must be an integer, got {type(schema_version).__name__}"
            )
        if schema_version > CURRENT_SCHEMA_VERSION:
            raise YAMLConfigError(
                f"Configuration schema version {schema_version} is not supported. "
                f"Maximum supported version is {CURRENT_SCHEMA_VERSION}. "
                "Please update Channel Weaver."
            )
        
        # Extract channels (required)
        channels = data.get('channels')
        if channels is None:
            raise YAMLConfigError("Missing required 'channels' section in configuration")
        if not isinstance(channels, list):
            raise YAMLConfigError(
                f"'channels' must be a list, got {type(channels).__name__}"
            )
        
        # Extract buses (optional, default to empty list)
        buses = data.get('buses', [])
        if not isinstance(buses, list):
            raise YAMLConfigError(
                f"'buses' must be a list, got {type(buses).__name__}"
            )
        
        return channels, buses, schema_version
```

**Key Implementation Notes:**
- Implements `ConfigSource` protocol
- Validates `schema_version` for forward compatibility
- Uses `yaml.safe_load()` to prevent arbitrary code execution
- Provides detailed error messages with line/column numbers

---

### Task 3: Create Default Config Source

**File:** `src/config/default_source.py`

```python
"""Default configuration source for Channel Weaver."""

from typing import Any

from src.config.defaults import CHANNELS, BUSES
from src.config.protocols import CURRENT_SCHEMA_VERSION


class DefaultConfigSource:
    """Provide built-in default configuration.
    
    Implements the ConfigSource protocol using the Python defaults
    defined in src/config/defaults.py.
    """
    
    @property
    def source_description(self) -> str:
        """Human-readable description of the config source."""
        return "built-in defaults"
    
    def load(self) -> tuple[list[dict[str, Any]], list[dict[str, Any]], int]:
        """Load the built-in default configuration.
        
        Returns:
            Tuple of (channels_data, buses_data, schema_version)
        """
        return list(CHANNELS), list(BUSES), CURRENT_SCHEMA_VERSION
```

---

### Task 4: Create Config File Generator

**File:** `src/config/generator.py`

```python
"""Configuration file generator for Channel Weaver."""

from pathlib import Path

import yaml

from src.config.defaults import CHANNELS, BUSES


# Template header with documentation
CONFIG_HEADER = """\
# Channel Weaver Configuration File
# ===================================
# 
# This file defines how input audio channels are processed and combined.
#
# CHANNELS SECTION
# ----------------
# Each channel entry defines processing for an input channel:
#
#   ch:        (required) Input channel number (1-32, 1-based indexing)
#   name:      (required) Display name for the channel (used in output filenames)
#   action:    (optional) Processing action - one of:
#              - PROCESS: Extract and output as individual mono file (default)
#              - SKIP: Ignore this channel entirely
#              - BUS: Reserve for stereo bus mixing (don't output individually)
#   output_ch: (optional) Override output channel number in filename
#              Defaults to the input channel number (ch)
#
# Any channels not listed here will be auto-created with action=PROCESS
# and name="Channel N" where N is the channel number.
#
# BUSES SECTION
# -------------
# Each bus entry combines multiple channels into a stereo output:
#
#   file_name: (required) Output filename (without .wav extension)
#   type:      (optional) Bus type - currently only STEREO supported
#   slots:     (required) Mapping of slot positions to input channels:
#              - LEFT: Channel number for left audio
#              - RIGHT: Channel number for right audio
#
# Channels assigned to buses should have action=BUS to avoid duplicate output.
#
# Example with all options:
#
#   channels:
#     - ch: 1
#       name: Kick
#       action: PROCESS
#     - ch: 7
#       name: Overhead L
#       action: BUS
#
#   buses:
#     - file_name: 07_Overheads
#       type: STEREO
#       slots:
#         LEFT: 7
#         RIGHT: 8

"""


class ConfigGenerator:
    """Generate example YAML configuration files.
    
    This class creates well-documented configuration files based on
    the default configuration or custom channel/bus definitions.
    """
    
    def __init__(
        self,
        channels: list[dict] | None = None,
        buses: list[dict] | None = None,
    ) -> None:
        """Initialize the config generator.
        
        Args:
            channels: Channel configurations (uses defaults if None)
            buses: Bus configurations (uses defaults if None)
        """
        self.channels = channels if channels is not None else CHANNELS
        self.buses = buses if buses is not None else BUSES
    
    def generate(self, output_path: Path, *, include_header: bool = True) -> None:
        """Generate a YAML configuration file.
        
        Args:
            output_path: Path where the config file will be written
            include_header: Whether to include documentation header
            
        Raises:
            OSError: If the file cannot be written
        """
        # Ensure parent directory exists
        output_path.parent.mkdir(parents=True, exist_ok=True)
        
        # Build config dictionary
        config = {
            'schema_version': 1,
            'channels': self.channels,
            'buses': self.buses,
        }
        
        # Generate YAML content
        yaml_content = yaml.safe_dump(
            config,
            default_flow_style=False,
            sort_keys=False,
            allow_unicode=True,
            indent=2,
            width=80,
        )
        
        # Write file
        with open(output_path, 'w', encoding='utf-8') as f:
            if include_header:
                f.write(CONFIG_HEADER)
            f.write(yaml_content)
    
    @classmethod
    def generate_minimal(cls, output_path: Path) -> None:
        """Generate a minimal example configuration.
        
        Creates a config with just essential examples, suitable for
        users who want to start from scratch.
        
        Args:
            output_path: Path where the config file will be written
        """
        minimal_channels = [
            {"ch": 1, "name": "Kick"},
            {"ch": 2, "name": "Snare"},
            {"ch": 3, "name": "Hi-Hat"},
            {"ch": 4, "name": "Overhead L", "action": "BUS"},
            {"ch": 5, "name": "Overhead R", "action": "BUS"},
        ]
        
        minimal_buses = [
            {
                "file_name": "04_Overheads",
                "type": "STEREO",
                "slots": {"LEFT": 4, "RIGHT": 5},
            }
        ]
        
        generator = cls(channels=minimal_channels, buses=minimal_buses)
        generator.generate(output_path)
```

**Key Implementation Notes:**
- Uses `yaml.safe_dump()` with `sort_keys=False` to preserve insertion order
- Includes comprehensive documentation header as comments
- Provides both full (from defaults) and minimal example generation
- Uses `indent=2` and `width=80` for readable output

---

### Task 5: Add Exception Type

**File:** `src/exceptions/config.py` (modify existing)

Add the new exception class:

```python
class YAMLConfigError(ConfigValidationError):
    """Exception raised for YAML configuration file errors.
    
    This includes:
    - File not found
    - YAML parsing errors
    - Invalid structure (missing sections, wrong types)
    - Unsupported schema version
    """
    pass
```

**File:** `src/exceptions/__init__.py` (modify existing)

Add export:

```python
from src.exceptions.config import (
    # ... existing imports ...
    YAMLConfigError,
)

__all__ = [
    # ... existing exports ...
    "YAMLConfigError",
]
```

---

### Task 6: Create Config Path Resolver

**File:** `src/config/resolver.py`

```python
"""Configuration path resolution for Channel Weaver."""

from pathlib import Path


# Default config file names (in order of preference)
DEFAULT_CONFIG_NAMES = [
    "channel_weaver.yaml",
    "channel_weaver.yml",
]


class ConfigResolver:
    """Resolve configuration file paths.
    
    Resolution order (first match wins):
    1. Explicit path provided via --config CLI option
    2. Config file in current working directory
    3. Fall back to built-in defaults (no file)
    
    Note: Configuration files are expected to be project-specific,
    so we only search the current working directory, not user home
    or global locations.
    """
    
    def __init__(self, explicit_path: Path | None = None) -> None:
        """Initialize the config resolver.
        
        Args:
            explicit_path: Explicitly provided config path (highest priority)
        """
        self.explicit_path = explicit_path
    
    def resolve(self) -> Path | None:
        """Resolve the configuration file path.
        
        Returns:
            Path to the config file, or None if using built-in defaults
            
        Raises:
            FileNotFoundError: If explicit_path is provided but doesn't exist
        """
        # 1. Explicit path (highest priority)
        if self.explicit_path is not None:
            if not self.explicit_path.exists():
                raise FileNotFoundError(
                    f"Configuration file not found: {self.explicit_path}"
                )
            return self.explicit_path
        
        # 2. Current working directory
        cwd_config = self._find_in_directory(Path.cwd())
        if cwd_config is not None:
            return cwd_config
        
        # 3. No config file found - will use built-in defaults
        return None
    
    def _find_in_directory(self, directory: Path) -> Path | None:
        """Search for a config file in the given directory.
        
        Args:
            directory: Directory to search
            
        Returns:
            Path to found config file, or None if not found
        """
        for name in DEFAULT_CONFIG_NAMES:
            config_path = directory / name
            if config_path.is_file():
                return config_path
        return None
    
    @staticmethod
    def get_default_path() -> Path:
        """Get the default path for creating new config files.
        
        Returns:
            Path in current working directory with primary config name
        """
        return Path.cwd() / DEFAULT_CONFIG_NAMES[0]
```

**Key Implementation Notes:**
- Simple resolution: explicit path → CWD → defaults
- No home directory or environment variable search (configs are project-specific)
- Supports `.yaml` and `.yml` extensions
- Returns `None` to indicate "use built-in defaults"

---

### Task 7: Update ConfigLoader Integration

**File:** `src/config/loader.py` (modify existing)

Update to accept a `ConfigSource` protocol:

```python
# Add imports at top
from pathlib import Path
from typing import Any

from src.config.protocols import ConfigSource, CURRENT_SCHEMA_VERSION
from src.config.yaml_source import YAMLConfigSource


class ConfigLoader:
    """Load and validate user-editable channel and bus definitions.
    
    This class processes configuration from any ConfigSource implementation,
    validates through Pydantic models, performs cross-validation between 
    channels and buses, and auto-fills missing channels.
    """

    def __init__(
            self,
            channels_data: Iterable[ChannelData],
            buses_data: Iterable[BusData],
            *,
            detected_channel_count: int | None = None,
            channel_validator: ChannelValidator | None = None,
            bus_validator: BusValidator | None = None,
            schema_version: int = CURRENT_SCHEMA_VERSION,
    ) -> None:
        """Initialize the configuration loader.
        
        Args:
            channels_data: Iterable of raw channel configuration dictionaries
            buses_data: Iterable of raw bus configuration dictionaries
            detected_channel_count: Number of channels detected in input audio
            channel_validator: Custom channel validator (uses default if None)
            bus_validator: Custom bus validator (uses default if None)
            schema_version: Schema version of the configuration
        """
        self._channels_data = list(channels_data)
        self._buses_data = list(buses_data)
        self._detected_channels = detected_channel_count
        self._schema_version = schema_version
        # ... rest of existing __init__ ...
    
    @classmethod
    def from_source(
        cls,
        source: ConfigSource,
        *,
        detected_channel_count: int | None = None,
        channel_validator: ChannelValidator | None = None,
        bus_validator: BusValidator | None = None,
    ) -> "ConfigLoader":
        """Create a ConfigLoader from any ConfigSource implementation.
        
        This factory method follows the Dependency Inversion Principle,
        accepting any implementation of the ConfigSource protocol.
        
        Args:
            source: Configuration source implementing ConfigSource protocol
            detected_channel_count: Number of channels detected in input audio
            channel_validator: Custom channel validator (uses default if None)
            bus_validator: Custom bus validator (uses default if None)
            
        Returns:
            ConfigLoader instance initialized from the source
        """
        channels_data, buses_data, schema_version = source.load()
        
        return cls(
            channels_data=channels_data,
            buses_data=buses_data,
            detected_channel_count=detected_channel_count,
            channel_validator=channel_validator,
            bus_validator=bus_validator,
            schema_version=schema_version,
        )
    
    @classmethod
    def from_yaml(
        cls,
        config_path: Path,
        *,
        detected_channel_count: int | None = None,
        channel_validator: ChannelValidator | None = None,
        bus_validator: BusValidator | None = None,
    ) -> "ConfigLoader":
        """Create a ConfigLoader from a YAML configuration file.
        
        Convenience method that creates a YAMLConfigSource and delegates
        to from_source().
        
        Args:
            config_path: Path to the YAML configuration file
            detected_channel_count: Number of channels detected in input audio
            channel_validator: Custom channel validator (uses default if None)
            bus_validator: Custom bus validator (uses default if None)
            
        Returns:
            ConfigLoader instance initialized with YAML configuration
        """
        source = YAMLConfigSource(config_path)
        return cls.from_source(
            source,
            detected_channel_count=detected_channel_count,
            channel_validator=channel_validator,
            bus_validator=bus_validator,
        )
```

---

### Task 8: Update CLI Commands

**File:** `src/cli/app.py` (modify existing)

Convert to multi-command structure:

```python
"""CLI application definition for Channel Weaver."""

import typer

from src.cli.commands import process, init_config, validate_config

app = typer.Typer(
    add_completion=False,
    help="Multitrack audio processor - process and organize live recordings.",
    no_args_is_help=True,
)

# Register commands
app.command(name="process", help="Process multitrack recordings")(process)
app.command(name="init-config", help="Generate an example configuration file")(init_config)
app.command(name="validate-config", help="Validate a configuration file")(validate_config)


@app.callback()
def main_callback() -> None:
    """Channel Weaver - Multitrack audio processing tool."""
    pass
```

**File:** `src/cli/commands.py` (modify existing)

Add the `--config` option and new commands:

```python
"""CLI command implementations for Channel Weaver."""

import logging
from pathlib import Path
from typing import Annotated, Optional

import typer
from rich.console import Console

from src.constants import VERSION
from src.exceptions import ConfigError, AudioProcessingError, YAMLConfigError
from src.audio.extractor import AudioExtractor
from src.processing.builder import TrackBuilder
from src.config import ConfigLoader, CHANNELS, BUSES, BitDepth
from src.config.resolver import ConfigResolver
from src.config.generator import ConfigGenerator
from src.cli.utils import _sanitize_path, _ensure_output_path, _determine_temp_dir

# Configure logging
logging.basicConfig(
    level=logging.WARNING,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)
logger = logging.getLogger(__name__)


def version_callback(value: bool) -> None:
    """Handle version flag callback for Typer CLI."""
    if value:
        typer.echo(f"Channel Weaver v{VERSION}")
        raise typer.Exit()


def process(
    input_path: Annotated[
        Path,
        typer.Argument(
            exists=True,
            file_okay=False,
            dir_okay=True,
            readable=True,
            resolve_path=True,
            help="Directory containing sequential WAV files",
        ),
    ],
    output: Annotated[
        Optional[Path],
        typer.Option(
            "--output", "-o",
            file_okay=False,
            dir_okay=True,
            resolve_path=True,
            help="Override the default output directory",
        ),
    ] = None,
    config: Annotated[
        Optional[Path],
        typer.Option(
            "--config", "-c",
            exists=True,
            file_okay=True,
            dir_okay=False,
            readable=True,
            resolve_path=True,
            help="Path to YAML configuration file",
        ),
    ] = None,
    bit_depth: Annotated[
        BitDepth,
        typer.Option(
            "--bit-depth",
            help="Target bit depth for output files (source=preserve original)",
        ),
    ] = BitDepth.SOURCE,
    temp_dir: Annotated[
        Optional[Path],
        typer.Option(
            "--temp-dir",
            file_okay=False,
            dir_okay=True,
            resolve_path=True,
            help="Custom temporary directory",
        ),
    ] = None,
    keep_temp: Annotated[
        bool,
        typer.Option(
            "--keep-temp",
            help="Keep temporary files instead of deleting them",
        ),
    ] = False,
    version: Annotated[
        Optional[bool],
        typer.Option(
            "--version", "-v",
            callback=version_callback,
            is_eager=True,
            is_flag=True,
            help="Show version and exit.",
        ),
    ] = None,
    verbose: Annotated[
        bool,
        typer.Option(
            "--verbose",
            help="Enable verbose debug output",
        ),
    ] = False,
) -> None:
    """Process multitrack recordings according to configuration."""
    # Configure logging level based on verbose flag
    if verbose:
        logging.getLogger().setLevel(logging.DEBUG)
        logger.debug("Verbose logging enabled")
    else:
        logging.getLogger().setLevel(logging.WARNING)

    console = Console()

    normalized_input = _sanitize_path(input_path)
    output_dir = _ensure_output_path(normalized_input, output)
    temp_root = _determine_temp_dir(output_dir, temp_dir)

    try:
        # Initialize AudioExtractor
        extractor = AudioExtractor(
            input_dir=normalized_input,
            temp_dir=temp_root,
            keep_temp=keep_temp,
            console=console,
        )

        # Discover and validate input files
        extractor.discover_and_validate()

        # Get detected channel count for ConfigLoader
        detected_channel_count = extractor.channels

        # Resolve and load configuration
        resolver = ConfigResolver(explicit_path=config)
        config_path = resolver.resolve()
        
        if config_path is not None:
            console.print(f"[dim]Using configuration: {config_path}[/dim]")
            config_loader = ConfigLoader.from_yaml(
                config_path,
                detected_channel_count=detected_channel_count,
            )
        else:
            # Use built-in defaults
            config_loader = ConfigLoader(
                CHANNELS,
                BUSES,
                detected_channel_count=detected_channel_count,
            )
        
        channels, buses = config_loader.load()

        # Extract segments
        segments = extractor.extract_segments(target_bit_depth=bit_depth)

        # Build tracks
        builder = TrackBuilder(
            sample_rate=extractor.sample_rate,  # type: ignore[arg-type]
            bit_depth=bit_depth,
            source_bit_depth=extractor.bit_depth,
            temp_dir=temp_root,
            output_dir=output_dir,
            keep_temp=keep_temp,
            console=console,
        )
        builder.build_tracks(channels, buses, segments)

    except YAMLConfigError as e:
        console.print(f"[red]Configuration Error:[/red] {e}")
        raise typer.Exit(code=1)
    except (ConfigError, AudioProcessingError) as e:
        console.print(f"[red]Error:[/red] {e}")
        raise typer.Exit(code=1)
    finally:
        if not keep_temp and 'extractor' in locals():
            extractor.cleanup()


def init_config(
    output: Annotated[
        Optional[Path],
        typer.Option(
            "--output", "-o",
            file_okay=True,
            dir_okay=False,
            resolve_path=True,
            help="Output path for the configuration file",
        ),
    ] = None,
    minimal: Annotated[
        bool,
        typer.Option(
            "--minimal", "-m",
            help="Generate a minimal example configuration",
        ),
    ] = False,
    force: Annotated[
        bool,
        typer.Option(
            "--force", "-f",
            help="Overwrite existing configuration file",
        ),
    ] = False,
) -> None:
    """Generate an example YAML configuration file.
    
    Creates a well-documented configuration file that you can customize
    for your specific multitrack setup.
    """
    console = Console()
    
    # Determine output path
    output_path = output or ConfigResolver.get_default_path()
    
    # Check for existing file
    if output_path.exists() and not force:
        console.print(
            f"[yellow]Configuration file already exists:[/yellow] {output_path}"
        )
        console.print("Use [bold]--force[/bold] to overwrite.")
        raise typer.Exit(code=1)
    
    try:
        if minimal:
            ConfigGenerator.generate_minimal(output_path)
        else:
            generator = ConfigGenerator()
            generator.generate(output_path)
        
        console.print(f"[green]Created configuration file:[/green] {output_path}")
        console.print("\nEdit this file to customize your channel and bus settings.")
        console.print(f"Then run: [bold]channel-weaver process <input_dir>[/bold]")
        
    except OSError as e:
        console.print(f"[red]Failed to write configuration file:[/red] {e}")
        raise typer.Exit(code=1)


def validate_config(
    config_path: Annotated[
        Path,
        typer.Argument(
            exists=True,
            file_okay=True,
            dir_okay=False,
            readable=True,
            resolve_path=True,
            help="Path to the configuration file to validate",
        ),
    ],
    channel_count: Annotated[
        Optional[int],
        typer.Option(
            "--channels", "-n",
            min=1,
            max=128,
            help="Expected channel count (for full validation)",
        ),
    ] = None,
) -> None:
    """Validate a YAML configuration file.
    
    Checks the configuration file for:
    - Valid YAML syntax
    - Correct schema structure
    - Valid channel and bus definitions
    - Cross-reference validation (if --channels provided)
    """
    console = Console()
    
    try:
        from src.config.yaml_source import YAMLConfigSource
        from src.config import ConfigLoader
        
        # Load and parse YAML
        source = YAMLConfigSource(config_path)
        channels_data, buses_data, schema_version = source.load()
        
        console.print(f"[dim]Schema version: {schema_version}[/dim]")
        console.print(f"[dim]Channels defined: {len(channels_data)}[/dim]")
        console.print(f"[dim]Buses defined: {len(buses_data)}[/dim]")
        
        # Full validation through ConfigLoader
        config_loader = ConfigLoader(
            channels_data,
            buses_data,
            detected_channel_count=channel_count,
            schema_version=schema_version,
        )
        channels, buses = config_loader.load()
        
        console.print(f"\n[green]✓ Configuration is valid[/green]")
        console.print(f"  Channels: {len(channels)}")
        console.print(f"  Buses: {len(buses)}")
        
        if channel_count:
            console.print(f"  Validated against {channel_count} channels")
        
    except YAMLConfigError as e:
        console.print(f"[red]✗ Configuration error:[/red] {e}")
        raise typer.Exit(code=1)
    except ConfigError as e:
        console.print(f"[red]✗ Validation error:[/red] {e}")
        raise typer.Exit(code=1)
```

---

### Task 9: Update Package Exports

**File:** `src/config/__init__.py` (modify existing)

Add new exports:

```python
"""Configuration package for Channel Weaver."""

# Re-export enums
from src.config.enums import ChannelAction, BusSlot, BusType, BitDepth

# Re-export models
from src.config.models import ChannelConfig, BusConfig

# Re-export validators
from src.config.validators import ChannelValidator, BusValidator

# Re-export loader
from src.config.loader import ConfigLoader

# Re-export protocols
from src.config.protocols import ConfigSource, CURRENT_SCHEMA_VERSION

# Re-export config sources
from src.config.yaml_source import YAMLConfigSource
from src.config.default_source import DefaultConfigSource
from src.config.generator import ConfigGenerator
from src.config.resolver import ConfigResolver

# Re-export defaults
from src.config.defaults import CHANNELS, BUSES

# Re-export types
from src.config.types import SegmentMap, ChannelData, BusData, AudioInfo, ChannelDict, BusDict

__all__ = [
    # Enums
    "ChannelAction",
    "BusSlot",
    "BusType",
    "BitDepth",
    # Models
    "ChannelConfig",
    "BusConfig",
    # Validators
    "ChannelValidator",
    "BusValidator",
    # Loader
    "ConfigLoader",
    # Protocols
    "ConfigSource",
    "CURRENT_SCHEMA_VERSION",
    # Config sources
    "YAMLConfigSource",
    "DefaultConfigSource",
    "ConfigGenerator",
    "ConfigResolver",
    # Defaults
    "CHANNELS",
    "BUSES",
    # Types
    "SegmentMap",
    "ChannelData",
    "BusData",
    "AudioInfo",
    "ChannelDict",
    "BusDict",
]
```

---

## File Structure Summary

After implementation, the new/modified files will be:

```
src/
├── config/
│   ├── __init__.py          # MODIFIED - add new exports
│   ├── protocols.py         # NEW - ConfigSource protocol
│   ├── yaml_source.py       # NEW - YAML config source
│   ├── default_source.py    # NEW - Default config source
│   ├── generator.py         # NEW - config file generation
│   ├── resolver.py          # NEW - config path resolution
│   ├── loader.py            # MODIFIED - add from_source() method
│   └── ... (existing files unchanged)
├── cli/
│   ├── app.py               # MODIFIED - multi-command structure
│   └── commands.py          # MODIFIED - add --config, init-config, validate-config
├── exceptions/
│   ├── __init__.py          # MODIFIED - export YAMLConfigError
│   └── config.py            # MODIFIED - add YAMLConfigError
└── ...
```

---

## Testing Plan

### Unit Tests

**File:** `tests/unit/config/test_protocols.py`

```python
"""Tests for config source protocols."""

import pytest
from typing import Any

from src.config.protocols import ConfigSource, CURRENT_SCHEMA_VERSION


class TestConfigSourceProtocol:
    """Tests for ConfigSource protocol compliance."""
    
    def test_yaml_source_implements_protocol(self) -> None:
        """Test that YAMLConfigSource implements ConfigSource."""
        from src.config.yaml_source import YAMLConfigSource
        
        assert isinstance(YAMLConfigSource, type)
        # Protocol check happens at instantiation with valid file
    
    def test_default_source_implements_protocol(self) -> None:
        """Test that DefaultConfigSource implements ConfigSource."""
        from src.config.default_source import DefaultConfigSource
        
        source = DefaultConfigSource()
        assert hasattr(source, 'load')
        assert hasattr(source, 'source_description')
        
        channels, buses, version = source.load()
        assert isinstance(channels, list)
        assert isinstance(buses, list)
        assert version == CURRENT_SCHEMA_VERSION
```

**File:** `tests/unit/config/test_yaml_source.py`

```python
"""Tests for YAML configuration source."""

import pytest
from pathlib import Path

from src.config.yaml_source import YAMLConfigSource, YAMLConfigError
from src.config.protocols import CURRENT_SCHEMA_VERSION


class TestYAMLConfigSource:
    """Tests for YAMLConfigSource class."""
    
    def test_load_valid_config(self, tmp_path: Path) -> None:
        """Test loading a valid YAML configuration."""
        config_file = tmp_path / "config.yaml"
        config_file.write_text("""
schema_version: 1
channels:
  - ch: 1
    name: Kick
  - ch: 2
    name: Snare
buses:
  - file_name: 01_Stereo
    type: STEREO
    slots:
      LEFT: 1
      RIGHT: 2
""")
        source = YAMLConfigSource(config_file)
        channels, buses, version = source.load()
        
        assert len(channels) == 2
        assert channels[0]["ch"] == 1
        assert channels[0]["name"] == "Kick"
        assert len(buses) == 1
        assert buses[0]["file_name"] == "01_Stereo"
        assert version == 1
    
    def test_load_missing_file(self, tmp_path: Path) -> None:
        """Test loading from non-existent file."""
        with pytest.raises(YAMLConfigError, match="not found"):
            YAMLConfigSource(tmp_path / "missing.yaml")
    
    def test_load_invalid_yaml(self, tmp_path: Path) -> None:
        """Test loading invalid YAML syntax."""
        config_file = tmp_path / "config.yaml"
        config_file.write_text("channels:\n  - ch: 1\n  name: broken")
        
        source = YAMLConfigSource(config_file)
        with pytest.raises(YAMLConfigError, match="Failed to parse"):
            source.load()
    
    def test_load_missing_channels_section(self, tmp_path: Path) -> None:
        """Test loading config without channels section."""
        config_file = tmp_path / "config.yaml"
        config_file.write_text("schema_version: 1\nbuses: []")
        
        source = YAMLConfigSource(config_file)
        with pytest.raises(YAMLConfigError, match="Missing required 'channels'"):
            source.load()
    
    def test_load_optional_buses(self, tmp_path: Path) -> None:
        """Test loading config without buses section (optional)."""
        config_file = tmp_path / "config.yaml"
        config_file.write_text("schema_version: 1\nchannels:\n  - ch: 1\n    name: Kick")
        
        source = YAMLConfigSource(config_file)
        channels, buses, version = source.load()
        
        assert len(channels) == 1
        assert buses == []
        assert version == 1
    
    def test_load_unsupported_schema_version(self, tmp_path: Path) -> None:
        """Test loading config with future schema version."""
        config_file = tmp_path / "config.yaml"
        config_file.write_text("schema_version: 999\nchannels:\n  - ch: 1\n    name: Kick")
        
        source = YAMLConfigSource(config_file)
        with pytest.raises(YAMLConfigError, match="not supported"):
            source.load()
    
    def test_source_description(self, tmp_path: Path) -> None:
        """Test source_description property."""
        config_file = tmp_path / "config.yaml"
        config_file.write_text("schema_version: 1\nchannels:\n  - ch: 1\n    name: Kick")
        
        source = YAMLConfigSource(config_file)
        assert "YAML file" in source.source_description
        assert str(config_file) in source.source_description
```

**File:** `tests/unit/config/test_generator.py`

```python
"""Tests for configuration file generator."""

import pytest
from pathlib import Path

import yaml

from src.config.generator import ConfigGenerator


class TestConfigGenerator:
    """Tests for ConfigGenerator class."""
    
    def test_generate_default_config(self, tmp_path: Path) -> None:
        """Test generating config with defaults."""
        output_file = tmp_path / "config.yaml"
        generator = ConfigGenerator()
        generator.generate(output_file)
        
        assert output_file.exists()
        
        # Verify it's valid YAML
        with open(output_file) as f:
            data = yaml.safe_load(f)
        
        assert "schema_version" in data
        assert data["schema_version"] == 1
        assert "channels" in data
        assert "buses" in data
    
    def test_generate_minimal_config(self, tmp_path: Path) -> None:
        """Test generating minimal config."""
        output_file = tmp_path / "config.yaml"
        ConfigGenerator.generate_minimal(output_file)
        
        assert output_file.exists()
        
        with open(output_file) as f:
            data = yaml.safe_load(f)
        
        assert len(data["channels"]) == 5
        assert len(data["buses"]) == 1
    
    def test_generate_includes_header(self, tmp_path: Path) -> None:
        """Test that generated file includes documentation header."""
        output_file = tmp_path / "config.yaml"
        generator = ConfigGenerator()
        generator.generate(output_file)
        
        content = output_file.read_text()
        assert "# Channel Weaver Configuration File" in content
    
    def test_generate_creates_parent_dirs(self, tmp_path: Path) -> None:
        """Test that generate creates parent directories."""
        output_file = tmp_path / "nested" / "deep" / "config.yaml"
        generator = ConfigGenerator()
        generator.generate(output_file)
        
        assert output_file.exists()
```

**File:** `tests/unit/config/test_resolver.py`

```python
"""Tests for configuration path resolver."""

import os
import pytest
from pathlib import Path
from unittest.mock import patch

from src.config.resolver import ConfigResolver


class TestConfigResolver:
    """Tests for ConfigResolver class."""
    
    def test_resolve_explicit_path(self, tmp_path: Path) -> None:
        """Test resolving explicit config path."""
        config_file = tmp_path / "my_config.yaml"
        config_file.touch()
        
        resolver = ConfigResolver(explicit_path=config_file)
        result = resolver.resolve()
        
        assert result == config_file
    
    def test_resolve_explicit_path_not_found(self, tmp_path: Path) -> None:
        """Test explicit path that doesn't exist raises error."""
        resolver = ConfigResolver(explicit_path=tmp_path / "missing.yaml")
        
        with pytest.raises(FileNotFoundError):
            resolver.resolve()
    
    def test_resolve_cwd_config(self, tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -> None:
        """Test finding config in current working directory."""
        monkeypatch.chdir(tmp_path)
        config_file = tmp_path / "channel_weaver.yaml"
        config_file.touch()
        
        resolver = ConfigResolver()
        result = resolver.resolve()
        
        assert result == config_file
    
    def test_resolve_returns_none_when_not_found(
        self, tmp_path: Path, monkeypatch: pytest.MonkeyPatch
    ) -> None:
        """Test that None is returned when no config is found."""
        monkeypatch.chdir(tmp_path)
        
        resolver = ConfigResolver()
        result = resolver.resolve()
        
        assert result is None
    
    def test_resolve_priority_explicit_over_cwd(
        self, tmp_path: Path, monkeypatch: pytest.MonkeyPatch
    ) -> None:
        """Test that explicit path takes priority over CWD discovery."""
        monkeypatch.chdir(tmp_path)
        
        # Create both an explicit config and a CWD config
        cwd_config = tmp_path / "channel_weaver.yaml"
        cwd_config.touch()
        explicit_config = tmp_path / "my_config.yaml"
        explicit_config.touch()
        
        resolver = ConfigResolver(explicit_path=explicit_config)
        result = resolver.resolve()
        
        # Explicit path should take priority
        assert result == explicit_config
```

### Integration Tests

**File:** `tests/integration/test_yaml_config_integration.py`

```python
"""Integration tests for YAML configuration loading."""

import pytest
from pathlib import Path

from src.config import ConfigLoader
from src.config.yaml_source import YAMLConfigSource


class TestYAMLConfigIntegration:
    """Integration tests for YAML config with ConfigLoader."""
    
    def test_full_config_load_and_validate(self, tmp_path: Path) -> None:
        """Test loading YAML config through full validation pipeline."""
        config_file = tmp_path / "config.yaml"
        config_file.write_text("""
schema_version: 1
channels:
  - ch: 1
    name: Kick
  - ch: 2
    name: Snare
  - ch: 3
    name: Overhead L
    action: BUS
  - ch: 4
    name: Overhead R
    action: BUS
buses:
  - file_name: 03_Overheads
    type: STEREO
    slots:
      LEFT: 3
      RIGHT: 4
""")
        
        source = YAMLConfigSource(config_file)
        loader = ConfigLoader.from_source(
            source,
            detected_channel_count=4,
        )
        channels, buses = loader.load()
        
        assert len(channels) == 4
        assert len(buses) == 1
        
        # Verify channel validation
        kick = next(ch for ch in channels if ch.ch == 1)
        assert kick.name == "Kick"
        
        # Verify bus validation
        assert buses[0].file_name == "03_Overheads"
```

---

## CLI Usage Examples

### After Implementation

```bash
# Process with auto-discovered config (in current working directory)
channel-weaver process ./recordings

# Process with explicit config file
channel-weaver process ./recordings --config ~/my_setup.yaml

# Process with short option
channel-weaver process ./recordings -c ./session_config.yaml

# Generate example config in current directory
channel-weaver init-config

# Generate minimal example config
channel-weaver init-config --minimal

# Generate config to specific path
channel-weaver init-config --output ~/configs/studio.yaml

# Overwrite existing config
channel-weaver init-config --force

# Validate a config file
channel-weaver validate-config channel_weaver.yaml

# Validate config with channel count check
channel-weaver validate-config channel_weaver.yaml --channels 32

# Show help
channel-weaver --help
channel-weaver process --help
channel-weaver init-config --help
channel-weaver validate-config --help
```

### Help Output

```
$ channel-weaver --help

 Usage: channel-weaver [OPTIONS] COMMAND [ARGS]...

 Multitrack audio processor - process and organize live recordings.

╭─ Options ─────────────────────────────────────────────────────────────────╮
│ --help          Show this message and exit.                               │
╰───────────────────────────────────────────────────────────────────────────╯
╭─ Commands ────────────────────────────────────────────────────────────────╮
│ process          Process multitrack recordings                            │
│ init-config      Generate an example configuration file                   │
│ validate-config  Validate a YAML configuration file                       │
╰───────────────────────────────────────────────────────────────────────────╯

$ channel-weaver process --help

 Usage: channel-weaver process [OPTIONS] INPUT_PATH

 Process multitrack recordings according to configuration.

╭─ Arguments ───────────────────────────────────────────────────────────────╮
│ *  INPUT_PATH    Directory containing sequential WAV files [required]     │
╰───────────────────────────────────────────────────────────────────────────╯
╭─ Options ─────────────────────────────────────────────────────────────────╮
│ --output,-o       PATH   Override the default output directory            │
│ --config,-c       PATH   Path to YAML configuration file                  │
│ --bit-depth       TEXT   Target bit depth (source|32float|24|16)          │
│ --temp-dir        PATH   Custom temporary directory                       │
│ --keep-temp              Keep temporary files                             │
│ --version,-v             Show version and exit                            │
│ --verbose                Enable verbose debug output                      │
│ --help                   Show this message and exit                       │
╰───────────────────────────────────────────────────────────────────────────╯

$ channel-weaver validate-config --help

 Usage: channel-weaver validate-config [OPTIONS] CONFIG_PATH

 Validate a YAML configuration file.

╭─ Arguments ───────────────────────────────────────────────────────────────╮
│ *  CONFIG_PATH    Path to the config file to validate [required]          │
╰───────────────────────────────────────────────────────────────────────────╯
╭─ Options ─────────────────────────────────────────────────────────────────╮
│ --channels        INTEGER  Number of detected channels to validate        │
│                            against (optional)                             │
│ --help                     Show this message and exit                     │
╰───────────────────────────────────────────────────────────────────────────╯
```

---

## Migration Guide

### For Existing Users

1. **Generate config from current defaults:**
   ```bash
   channel-weaver init-config --output channel_weaver.yaml
   ```

2. **Edit the generated file** to match your setup

3. **Run with new config:**
   ```bash
   channel-weaver process ./input_dir
   # Automatically finds channel_weaver.yaml in cwd
   ```

### Backward Compatibility

- The `defaults.py` file remains as fallback
- If no config file is found, behavior is identical to before
- All existing CLI options continue to work

---

## Quality Assurance Checklist

After implementation, run:

```bash
# Run all tests
uv run pytest

# Type checking
uv run mypy src/ tests/

# Linting
uv run ruff check src/ tests/

# Test coverage
uv run pytest --cov=src --cov-report=html
```

---

## Future Enhancements (Out of Scope)

- Support for JSON config files (in addition to YAML)
- Config file merging (layered configs)
- Per-project vs global config precedence
- Schema migration tools for version upgrades
